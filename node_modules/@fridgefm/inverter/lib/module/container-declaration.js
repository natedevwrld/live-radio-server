"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.declareContainer = exports.CHILD_DI_FACTORY_TOKEN = void 0;
const base_container_1 = require("../base/base-container");
const errors_1 = require("../base/errors");
const token_1 = require("../base/token");
const internals_1 = require("../base/internals");
const extractDeclaration = (tokenDeclaration) => {
    if ('token' in tokenDeclaration) {
        return tokenDeclaration;
    }
    return {
        token: tokenDeclaration,
        optional: false,
    };
};
const orderModuleProviders = (modules, events) => {
    const uniqProviders = new Set();
    const traverseModules = (importedModules, parentName) => {
        importedModules === null || importedModules === void 0 ? void 0 : importedModules.forEach((moduleDec) => {
            var _a;
            const { providers, imports = [], name } = moduleDec.__internals;
            traverseModules(imports, name);
            (_a = events === null || events === void 0 ? void 0 : events.moduleRegistered) === null || _a === void 0 ? void 0 : _a.call(events, moduleDec, parentName);
            providers.forEach((providerDec) => {
                var _a;
                if (uniqProviders.has(providerDec)) {
                    // this ensures the correct resolve order - the latest added provider is set for resolve (see tests for additional info)
                    uniqProviders.delete(providerDec);
                }
                uniqProviders.add(providerDec);
                (_a = events === null || events === void 0 ? void 0 : events.providerRegistered) === null || _a === void 0 ? void 0 : _a.call(events, providerDec);
            });
        });
    };
    traverseModules(modules, 'Container');
    return Array.from(uniqProviders.values());
};
/**
 * Token for creating child containers, an injectable should be passed as the root of this container
 */
exports.CHILD_DI_FACTORY_TOKEN = (0, token_1.createToken)('inverter:child-di-factory');
const declareContainer = ({ providers = [], modules = [], parent, events }) => {
    var _a, _b;
    (_a = events === null || events === void 0 ? void 0 : events.containerStart) === null || _a === void 0 ? void 0 : _a.call(events);
    const container = (0, base_container_1.createBaseContainer)(parent);
    const resolvingTokens = new Set(); // for cycle dep check
    const allProviders = [...orderModuleProviders(modules, events), ...providers];
    const traverseProviders = (provider, stack) => {
        var _a;
        (_a = provider.inject) === null || _a === void 0 ? void 0 : _a.forEach((dec) => {
            const { token, optional } = extractDeclaration(dec);
            const provided = allProviders.find((x) => x.provide === token);
            stack.push(token);
            if (typeof provided === 'undefined') {
                if (optional || typeof token.optionalValue !== 'undefined') {
                    return;
                }
                throw new errors_1.ResolverError(stack);
            }
            traverseProviders(provided, stack);
        });
    };
    // @ts-ignore
    container.bindValue(exports.CHILD_DI_FACTORY_TOKEN, (childProvider) => {
        // before we can start creating child di first should check that everything is correctly provided
        // yes, this is a pretty costly operation but we better do it once at start rather than get runtime errors
        traverseProviders(childProvider, [childProvider.provide]);
        return () => (0, exports.declareContainer)({
            parent: container,
            providers: [childProvider],
            events,
        }).get(childProvider.provide);
    });
    allProviders.forEach((injectableDep) => {
        var _a;
        const { inject, provide, useFactory, useValue, scope } = injectableDep;
        if (typeof useFactory !== 'undefined') {
            container.bindFactory(provide, (ctx) => {
                var _a;
                inject === null || inject === void 0 ? void 0 : inject.forEach((tokenDeclaration) => {
                    // check if there is a cycle
                    if (resolvingTokens.has(extractDeclaration(tokenDeclaration).token)) {
                        throw new errors_1.CyclicDepError([provide, ...Array.from(resolvingTokens)]);
                    }
                });
                const resolvedDeps = inject === null || inject === void 0 ? void 0 : inject.map((tokenDeclaration) => {
                    const { token, optional } = extractDeclaration(tokenDeclaration);
                    // mark current resolving dep
                    resolvingTokens.add(token);
                    const resolvedValue = ctx.resolve(token);
                    // delete it after it is resolved
                    resolvingTokens.delete(token);
                    if (resolvedValue === internals_1.NOT_FOUND_SYMBOL) {
                        if (optional) {
                            return undefined;
                        }
                        traverseProviders(injectableDep, [provide]);
                    }
                    return resolvedValue;
                });
                (_a = events === null || events === void 0 ? void 0 : events.providerResolveEnd) === null || _a === void 0 ? void 0 : _a.call(events, injectableDep);
                return useFactory(...(resolvedDeps || []));
            }, { scope });
        }
        else {
            (_a = events === null || events === void 0 ? void 0 : events.providerResolveEnd) === null || _a === void 0 ? void 0 : _a.call(events, injectableDep);
            container.bindValue(provide, useValue);
        }
    });
    (_b = events === null || events === void 0 ? void 0 : events.containerReady) === null || _b === void 0 ? void 0 : _b.call(events);
    return container;
};
exports.declareContainer = declareContainer;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udGFpbmVyLWRlY2xhcmF0aW9uLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL21vZHVsZS9jb250YWluZXItZGVjbGFyYXRpb24udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsMkRBQTZEO0FBQzdELDJDQUErRDtBQUMvRCx5Q0FBNEM7QUFDNUMsaURBQXFEO0FBUXJELE1BQU0sa0JBQWtCLEdBQUcsQ0FDekIsZ0JBQW9DLEVBSXBDLEVBQUU7SUFDRixJQUFJLE9BQU8sSUFBSSxnQkFBZ0IsRUFBRTtRQUMvQixPQUFPLGdCQUFnQixDQUFDO0tBQ3pCO0lBQ0QsT0FBTztRQUNMLEtBQUssRUFBRSxnQkFBZ0I7UUFDdkIsUUFBUSxFQUFFLEtBQUs7S0FDaEIsQ0FBQztBQUNKLENBQUMsQ0FBQztBQUVGLE1BQU0sb0JBQW9CLEdBQUcsQ0FBQyxPQUE0QixFQUFFLE1BQXdCLEVBQTJCLEVBQUU7SUFDL0csTUFBTSxhQUFhLEdBQUcsSUFBSSxHQUFHLEVBQXlCLENBQUM7SUFDdkQsTUFBTSxlQUFlLEdBQUcsQ0FBQyxlQUFvQyxFQUFFLFVBQWtCLEVBQUUsRUFBRTtRQUNuRixlQUFlLGFBQWYsZUFBZSx1QkFBZixlQUFlLENBQUUsT0FBTyxDQUFDLENBQUMsU0FBUyxFQUFFLEVBQUU7O1lBQ3JDLE1BQU0sRUFBRSxTQUFTLEVBQUUsT0FBTyxHQUFHLEVBQUUsRUFBRSxJQUFJLEVBQUUsR0FBRyxTQUFTLENBQUMsV0FBVyxDQUFDO1lBQ2hFLGVBQWUsQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLENBQUM7WUFDL0IsTUFBQSxNQUFNLGFBQU4sTUFBTSx1QkFBTixNQUFNLENBQUUsZ0JBQWdCLCtDQUF4QixNQUFNLEVBQXFCLFNBQVMsRUFBRSxVQUFVLENBQUMsQ0FBQztZQUNsRCxTQUFTLENBQUMsT0FBTyxDQUFDLENBQUMsV0FBVyxFQUFFLEVBQUU7O2dCQUNoQyxJQUFJLGFBQWEsQ0FBQyxHQUFHLENBQUMsV0FBVyxD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